[{"name":"app.R","content":"# app.R\nlibrary(shiny)\nlibrary(leaflet)\nlibrary(readr)\nlibrary(DT)\nlibrary(jsonlite)\n\n`%||%` <- function(a, b) if (!is.null(a)) a else b\nTZ_LOCAL <- \"America/Los_Angeles\"  # Pacific\n\nui <- fluidPage(\n  tags$h2(\"Movebank Data Viewer\"),\n  \n  tags$style(HTML(\"\n    .map-wrap { width: 100%; }\n    .map-tall { height: 760px; }\n    .map-short { height: 520px; }\n\n    table.dataTable tbody th, table.dataTable tbody td { font-size: 12px; }\n    table.dataTable thead th { font-size: 12px; }\n\n    .tbl-wrap { height: 340px; overflow: auto; }\n\n    div.dataTables_wrapper { width: 100%; }\n    div.dataTables_scroll { width: 100%; }\n    div.dataTables_scrollBody {\n      overflow-x: auto !important;\n      overflow-y: auto !important;\n    }\n    div.dataTables_scrollHeadInner,\n    div.dataTables_scrollHeadInner table,\n    div.dataTables_scrollBody table.dataTable {\n      width: max-content !important;\n    }\n    table.dataTable { white-space: nowrap; }\n\n    .color-row { display:flex; align-items:center; gap:10px; }\n    .color-row label { margin:0; font-weight:600; }\n    .color-row input[type='color'] { width:46px; height:30px; padding:0; border:none; background:transparent; }\n  \")),\n  \n  fluidRow(\n    column(\n      4,\n      wellPanel(\n        tabsetPanel(\n          id = \"left_tabs\",\n          \n          tabPanel(\n            \"Data\",\n            textInput(\"mb_user\", \"Movebank username\", value = \"r6snrf\"),\n            passwordInput(\"mb_pass\", \"Movebank password\", value = \"\"),\n            numericInput(\"study_id\", \"Study ID\", value = 8038997102, min = 1, step = 1),\n            textInput(\"sensor_type_id\", \"Sensor type id (optional)\", value = \"\"),\n            checkboxInput(\"accept_license\", \"accept_license=true\", value = FALSE),\n            \n            tags$hr(),\n            \n            sliderInput(\n              \"max_points\",\n              \"Max points to display (after filtering)\",\n              min = 200, max = 20000, value = 5000, step = 200\n            ),\n            tags$small(style=\"display:block; margin-top:-6px; color:#666;\",\n                       \"If filtered data exceeds this, we keep the most recent points.\"),\n            \n            tags$hr(),\n            \n            actionButton(\"fetch\", \"Load Collar Data\"),\n            \n            tags$hr(),\n            \n            tags$strong(\"Newest point (Pacific): \"),\n            textOutput(\"newest_pt_local\", inline = TRUE),\n            \n            tags$hr(),\n            \n            \n            \n            \n            checkboxInput(\"fit_data\", \"Zoom to data after plotting\", value = TRUE),\n            \n            tags$hr(),\n            verbatimTextOutput(\"status\")\n          ),\n          \n          tabPanel(\n            \"Filtering\",\n            selectInput(\n              \"last_n_days\",\n              \"Filter: last N days (anchored to newest loaded data point)\",\n              choices = c(\"Off\" = \"off\", \"1\" = \"1\", \"2\" = \"2\", \"3\" = \"3\", \"5\" = \"5\", \"10\" = \"10\"),\n              selected = \"off\"\n            ),\n            uiOutput(\"date_ui\"),\n            tags$small(style=\"display:block; margin-top:-6px; color:#666;\",\n                       \"If 'last N days' is set, it overrides the date range.\"),\n            checkboxInput(\n              \"keep_qpf_only\",\n              \"Keep only good fixes (gps_fix_type_raw contains 'QFP')\",\n              value = FALSE\n            ),\n            \n          ),\n          \n          tabPanel(\n            \"Table\",\n            checkboxInput(\"show_table\", \"Show table (split view)\", value = TRUE),\n            checkboxInput(\"fit_selected\", \"Zoom to selected rows\", value = FALSE),\n            tags$hr(),\n            uiOutput(\"col_ui\")\n          ),\n          \n          tabPanel(\n            \"Display\",\n            sliderInput(\"pt_radius\", \"Point size\", min = 1, max = 12, value = 3, step = 1),\n            \n            selectInput(\n              \"pt_color_mode\",\n              \"Point color\",\n              choices = c(\"By individual\" = \"by_id\", \"Single color\" = \"single\"),\n              selected = \"by_id\"\n            ),\n            \n            conditionalPanel(\n              condition = \"input.pt_color_mode === 'single'\",\n              tags$div(\n                class = \"color-row\",\n                tags$label(`for` = \"pt_color_single\", \"Pick color:\"),\n                tags$input(id = \"pt_color_single\", type = \"color\", value = \"#1f77b4\")\n              )\n            ),\n            \n            tags$hr(),\n            \n            selectizeInput(\"ind_select\", \"Individuals for tracks (optional)\", choices = NULL, multiple = TRUE),\n            checkboxInput(\"show_tracks\", \"Draw tracks for selected individuals\", value = FALSE),\n            checkboxInput(\"show_track_key\", \"Show track color key\", value = TRUE),\n            \n            \n          ),\n          tabPanel(\n            \"Export\",\n            helpText(\"testing 2 : Export the currently filtered table data.\"),\n            tags$hr(),\n            actionButton(\"btn_csv\", \"Download filtered CSV\"),\n            tags$div(style=\"height:8px;\"),\n            tags$hr(),\n            actionButton(\"btn_pts_geojson\", \"Download Caltopo GeoJSON (points)\"),\n            tags$div(style=\"height:8px;\"),\n            tags$hr(),\n            \n            tags$div(style=\"height:8px;\"),\n            actionButton(\"btn_tracks_geojson\", \"Download Caltopo Tracks GeoJSON\"),\n            tags$small(style=\"display:block; color:#666;\",\n                       \"On the Display tab, individual must be selected and tracks turned on. \n                       If tracks are not on, the export will be empty\"),\n            \n            tags$hr(),\n            tags$hr(),\n            tags$small(\"Tip: The export uses the current filters (last N days / date range) and max points cap.\"),\n            \n            \n\n            \n          )\n          \n        )\n      )\n    ),\n    \n    column(\n      8,\n      tags$div(\n        id = \"map_container\",\n        class = \"map-wrap map-short\",\n        leafletOutput(\"map\", height = \"100%\")\n      ),\n      \n      conditionalPanel(\n        condition = \"input.show_table === true\",\n        tags$div(style = \"height: 12px;\"),\n        div(class = \"tbl-wrap\", DTOutput(\"tbl\"))\n      )\n    )\n  ),\n  \n  # ---- JS fetcher + map resize handler + color picker binding ----\n  tags$script(HTML(\"\n  function basicAuthHeader(user, pass) {\n    return 'Basic ' + btoa(user + ':' + pass);\n  }\n\n  async function fetchMovebankCSV(payload) {\n    const { study_id, sensor_type_id, accept_license, user, pass } = payload;\n\n    let url = 'https://www.movebank.org/movebank/service/direct-read'\n            + '?entity_type=event'\n            + '&study_id=' + encodeURIComponent(study_id)\n            + '&attributes=all'\n            + '&format=csv';\n\n    if (sensor_type_id && sensor_type_id.trim() !== '') {\n      url += '&sensor_type_id=' + encodeURIComponent(sensor_type_id.trim());\n    }\n    if (accept_license) {\n      url += '&accept_license=true';\n    }\n\n    try {\n      Shiny.setInputValue('mb_status', 'Fetching…', {priority: 'event'});\n\n      const res = await fetch(url, {\n        method: 'GET',\n        mode: 'cors',\n        headers: { 'Authorization': basicAuthHeader(user, pass) }\n      });\n\n      if (!res.ok) {\n        const txt = await res.text();\n        throw new Error('HTTP ' + res.status + ': ' + txt.slice(0, 300));\n      }\n\n      const csvText = await res.text();\n      Shiny.setInputValue('mb_csv_text', csvText, {priority: 'event'});\n      Shiny.setInputValue('mb_status', 'Success: received ' + csvText.length + ' bytes', {priority: 'event'});\n    } catch (err) {\n      Shiny.setInputValue('mb_status', 'Error: ' + err.message, {priority: 'event'});\n      Shiny.setInputValue('mb_csv_text', null, {priority: 'event'});\n    }\n  }\n\n  Shiny.addCustomMessageHandler('fetch_movebank', function(payload) {\n    fetchMovebankCSV(payload);\n  });\n\n  Shiny.addCustomMessageHandler('set_map_height', function(payload) {\n    var el = document.getElementById('map_container');\n    if (!el) return;\n\n    el.classList.remove('map-tall','map-short');\n    el.classList.add(payload.tall ? 'map-tall' : 'map-short');\n\n    setTimeout(function() {\n      if (window.LeafletWidget && LeafletWidget.maps && LeafletWidget.maps.map) {\n        LeafletWidget.maps.map.invalidateSize(true);\n      }\n    }, 80);\n  });\n\n  // ---- Bind native <input type=\\\"color\\\"> to Shiny ----\n  function bindColorPicker() {\n  // In shinylive, Shiny may not exist yet at DOMContentLoaded\n  if (!window.Shiny || typeof Shiny.setInputValue !== 'function') return;\n\n  var el = document.getElementById('pt_color_single');\n  if (!el) return;\n\n  Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n\n  el.addEventListener('input', function() {\n    Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n  });\n  el.addEventListener('change', function() {\n    Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n  });\n}\n\n  document.addEventListener('DOMContentLoaded', function() {\n    setTimeout(bindColorPicker, 0);\n  });\n\n  document.addEventListener('shiny:connected', function() {\n    setTimeout(bindColorPicker, 0);\n  });\n\n  if (window.jQuery) {\n    $(document).on('shiny:value', function() {\n      setTimeout(bindColorPicker, 0);\n    });\n    \n    // ---- client-side download helper (works on GitHub Pages) ----\n  function downloadTextFile(filename, mimeType, text) {\n    try {\n      const blob = new Blob([text], { type: mimeType });\n      const url = URL.createObjectURL(blob);\n  \n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n  \n      setTimeout(() => {\n        URL.revokeObjectURL(url);\n        a.remove();\n      }, 100);\n    } catch (e) {\n      console.error('Download failed:', e);\n      alert('Download failed:'  + e.message);\n    }\n  }\n\nShiny.addCustomMessageHandler('download_text_file', function(payload) {\n  downloadTextFile(payload.filename, payload.mimetype, payload.text);\n});\n\n    \n  }\n  \"))\n)\n\nserver <- function(input, output, session) {\n  \n  raw_dat <- reactiveVal(NULL)\n  \n  output$newest_pt_local <- renderText({\n    df <- raw_dat()\n    if (is.null(df) || !(\"timestamp_utc\" %in% names(df)) || all(is.na(df$timestamp_utc))) {\n      return(\"—\")\n    }\n    tmax <- suppressWarnings(max(df$timestamp_utc, na.rm = TRUE))\n    if (!is.finite(tmax)) return(\"—\")\n    \n    paste0(format(tmax, tz = TZ_LOCAL, usetz = TRUE), \"  (n=\", nrow(df), \")\")\n  })\n  \n  \n  # ---- Track key ----\n  track_key_html <- function(new_col, old_col) {\n    sprintf(\"\n    <div style='background: rgba(255,255,255,0.92); padding: 6px 8px; border-radius: 6px;\n                box-shadow: 0 1px 4px rgba(0,0,0,0.25); font-size: 12px; line-height: 14px;'>\n      <div style='display:flex; align-items:center; gap:8px;'>\n        <span style='display:inline-block; width:14px; height:14px; background:%s; border:1px solid #333;'><\/span>\n        <span>Newer<\/span>\n      <\/div>\n      <div style='display:flex; align-items:center; gap:8px; margin-top:4px;'>\n        <span style='display:inline-block; width:14px; height:14px; background:%s; border:1px solid #333;'><\/span>\n        <span>Older<\/span>\n      <\/div>\n    <\/div>\", new_col, old_col\n    )\n  }\n  \n  # ---- track redraw trigger (stable) ----\n  track_redraw <- reactiveVal(0)\n  \n  observeEvent(input$show_tracks, {\n    if (isTRUE(input$show_tracks)) {\n      session$onFlushed(function() {\n        track_redraw(isolate(track_redraw()) + 1)\n      }, once = TRUE)\n    } else {\n      leafletProxy(\"map\") %>%\n        clearGroup(\"tracks\") %>%\n        removeControl(\"track_key\")\n    }\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$ind_select, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$date_rng, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$last_n_days, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$max_points, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  # ---- Fetch ----\n  observeEvent(input$fetch, {\n    req(input$mb_user, input$mb_pass, input$study_id)\n    session$sendCustomMessage(\"fetch_movebank\", list(\n      user = input$mb_user,\n      pass = input$mb_pass,\n      study_id = input$study_id,\n      sensor_type_id = input$sensor_type_id,\n      accept_license = isTRUE(input$accept_license)\n    ))\n  })\n  \n  observeEvent(input$mb_csv_text, {\n    req(input$mb_csv_text)\n    \n    df <- readr::read_csv(I(input$mb_csv_text), show_col_types = FALSE)\n    names(df) <- gsub(\"-\", \"_\", names(df))\n    \n    req(\"location_lat\" %in% names(df), \"location_long\" %in% names(df))\n    \n    if (\"timestamp\" %in% names(df)) {\n      df$timestamp_utc <- suppressWarnings(as.POSIXct(df$timestamp, tz = \"UTC\"))\n    } else {\n      df$timestamp_utc <- as.POSIXct(NA)\n    }\n    \n    df$timestamp_pacific <- ifelse(\n      is.na(df$timestamp_utc),\n      NA_character_,\n      format(df$timestamp_utc, tz = TZ_LOCAL, usetz = TRUE)\n    )\n    \n    df$row_id <- seq_len(nrow(df))\n    raw_dat(df)\n  })\n  \n  output$status <- renderText(input$mb_status %||% \"Idle.\")\n  \n  observeEvent(input$show_table, {\n    session$sendCustomMessage(\"set_map_height\", list(tall = !isTRUE(input$show_table)))\n  }, ignoreInit = FALSE)\n  \n  # Date UI\n  output$date_ui <- renderUI({\n    df <- raw_dat()\n    if (is.null(df) || all(is.na(df$timestamp_utc))) {\n      return(helpText(\"Date range: (timestamp not available in data)\"))\n    }\n    pac_dates <- as.Date(df$timestamp_utc, tz = TZ_LOCAL)\n    rng <- range(pac_dates, na.rm = TRUE)\n    \n    dateRangeInput(\n      \"date_rng\",\n      paste0(\"Date range (\", TZ_LOCAL, \")\"),\n      start = rng[1],\n      end = rng[2]\n    )\n  })\n  \n  output$col_ui <- renderUI({\n    df <- raw_dat()\n    if (is.null(df)) return(NULL)\n    \n    desired <- c(\n      \"individual_local_identifier\",\n      \"timestamp_pacific\",\n      \"location_lat\",\n      \"location_long\",\n      \"gps_fix_type_raw\"\n    )\n    default_cols <- desired[desired %in% names(df)]\n    \n    checkboxGroupInput(\n      \"show_cols\",\n      \"Table columns\",\n      choices = names(df),\n      selected = default_cols\n    )\n  })\n  \n  observeEvent(raw_dat(), {\n    df <- raw_dat()\n    if (is.null(df)) return()\n    \n    inds <- if (\"individual_local_identifier\" %in% names(df)) {\n      sort(unique(df$individual_local_identifier))\n    } else character(0)\n    \n    updateSelectizeInput(session, \"ind_select\", choices = inds, selected = character(0), server = TRUE)\n  })\n  \n  # ---- Filtering + capping helpers ----\n  apply_filters <- function(df) {\n    if (is.null(df) || nrow(df) == 0) return(df)\n    \n    df <- df[is.finite(df$location_lat) & is.finite(df$location_long), , drop = FALSE]\n    if (nrow(df) == 0) return(df)\n    \n    # optional fix-quality filter\n    if (isTRUE(input$keep_qpf_only)) {\n      if (\"gps_fix_type_raw\" %in% names(df)) {\n        df <- df[grepl(\"QFP\", df$gps_fix_type_raw %||% \"\", fixed = TRUE), , drop = FALSE]\n      } else {\n        # if field missing, return empty rather than silently ignoring\n        df <- df[0, , drop = FALSE]\n      }\n      if (nrow(df) == 0) return(df)\n    }\n    \n    \n    has_time <- \"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))\n    \n    # last N days anchored to newest loaded point wins\n    if (has_time && !is.null(input$last_n_days) && input$last_n_days != \"off\") {\n      nd <- as.integer(input$last_n_days)\n      end_utc <- suppressWarnings(max(df$timestamp_utc, na.rm = TRUE))\n      if (is.finite(end_utc)) {\n        start_utc <- end_utc - (nd * 86400)\n        df <- df[df$timestamp_utc >= start_utc & df$timestamp_utc <= end_utc, , drop = FALSE]\n      }\n      return(df)\n    }\n    \n    # otherwise date range\n    if (has_time && !is.null(input$date_rng) && all(!is.na(input$date_rng))) {\n      start_local <- as.POSIXct(paste0(input$date_rng[1], \" 00:00:00\"), tz = TZ_LOCAL)\n      end_local   <- as.POSIXct(paste0(input$date_rng[2], \" 23:59:59\"), tz = TZ_LOCAL)\n      \n      start_utc <- as.POSIXct(format(start_local, tz = \"UTC\", usetz = TRUE), tz = \"UTC\")\n      end_utc   <- as.POSIXct(format(end_local,   tz = \"UTC\", usetz = TRUE), tz = \"UTC\")\n      \n      df <- df[df$timestamp_utc >= start_utc & df$timestamp_utc <= end_utc, , drop = FALSE]\n    }\n    \n    df\n  }\n  \n  cap_points <- function(df, nmax) {\n    if (is.null(df) || nrow(df) == 0) return(df)\n    if (is.null(nmax) || !is.finite(nmax) || nrow(df) <= nmax) return(df)\n    \n    if (\"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))) {\n      o <- order(df$timestamp_utc, decreasing = TRUE)\n      df <- df[o, , drop = FALSE]\n      df <- df[seq_len(nmax), , drop = FALSE]\n      df <- df[order(df$timestamp_utc), , drop = FALSE]\n    } else {\n      df <- df[seq.int(max(1, nrow(df) - nmax + 1), nrow(df)), , drop = FALSE]\n    }\n    df\n  }\n  \n  # ---- Caltopo GeoJSON builder ----\n  make_caltopo_geojson <- function(df) {\n    if (is.null(df) || nrow(df) == 0) {\n      return('{\"type\":\"FeatureCollection\",\"features\":[]}')\n    }\n\n    # Ensure required fields exist\n    req_cols <- c(\"location_lat\", \"location_long\", \"timestamp_pacific\",\n                  \"individual_local_identifier\", \"gps_fix_type_raw\")\n    for (nm in req_cols) if (!nm %in% names(df)) df[[nm]] <- NA\n\n    # Determine age order for gradient coloring (older -> newer)\n    if (\"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))) {\n      o <- order(df$timestamp_utc, na.last = TRUE)\n    } else {\n      o <- seq_len(nrow(df))\n    }\n\n    n <- nrow(df)\n    grad_cols <- grDevices::colorRampPalette(c(\"#440154\", \"#21908C\", \"#FDE725\"))(max(1, n))\n    cols_by_row <- rep(NA_character_, n)\n    cols_by_row[o] <- grad_cols[seq_len(n)]\n\n    # Convert colors to Caltopo format: \"FF0000\" (no #, uppercase)\n    cal_color <- toupper(gsub(\"^#\", \"\", cols_by_row))\n\n    # Build features\n    features <- vector(\"list\", n)\n    for (i in seq_len(n)) {\n      lon <- df$location_long[i]\n      lat <- df$location_lat[i]\n      if (!is.finite(lon) || !is.finite(lat)) next\n\n      title <- as.character(df$timestamp_pacific[i] %||% \"\")\n      desc <- paste0(\n        \"id: \", (df$individual_local_identifier[i] %||% \"\"), \"\\n\",\n        \"gps type: \", (df$gps_fix_type_raw[i] %||% \"\"), \"\\n\",\n        \"date_time: \", (df$timestamp_pacific[i] %||% \"\")\n      )\n\n      features[[i]] <- list(\n        type = \"Feature\",\n        geometry = list(\n          type = \"Point\",\n          coordinates = list(as.numeric(lon), as.numeric(lat))\n        ),\n        properties = list(\n          `marker-symbol` = \"point\",\n          `marker-color`  = cal_color[i],\n          description     = desc,\n          title           = title,\n          `marker-size`   = \"1.5\",\n          class           = \"Marker\",\n          folderId        = NULL,\n          `marker-rotation` = NULL\n        )\n      )\n    }\n\n    # Drop NULLs from skipped rows (if any)\n    features <- Filter(Negate(is.null), features)\n\n    geo <- list(type = \"FeatureCollection\", features = features)\n\n    # jsonlite is the cleanest way to emit valid JSON\n    jsonlite::toJSON(geo, auto_unbox = TRUE, null = \"null\", digits = 8)\n  }\n\n  \n  \n  \n  \n  plot_df <- reactive({\n    df <- raw_dat()\n    req(df)\n    df2 <- apply_filters(df)\n    cap_points(df2, input$max_points)\n  })\n  \n  track_df <- reactive({\n    df <- raw_dat()\n    req(df)\n    req(isTRUE(input$show_tracks))\n    req(length(input$ind_select) > 0)\n    \n    if (!(\"individual_local_identifier\" %in% names(df))) return(df[0, , drop = FALSE])\n    \n    df2 <- df[df$individual_local_identifier %in% input$ind_select, , drop = FALSE]\n    df2 <- apply_filters(df2)\n    df2 <- cap_points(df2, input$max_points)\n    \n    if (\"timestamp_utc\" %in% names(df2)) {\n      df2 <- df2[order(df2$individual_local_identifier, df2$timestamp_utc), , drop = FALSE]\n    } else {\n      df2 <- df2[order(df2$individual_local_identifier), , drop = FALSE]\n    }\n    df2\n  })\n  \n  \n  # ## download json\n  # output$dl_caltopo_geojson <- downloadHandler(\n  #   filename = function() {\n  #     paste0(\"caltopo_export_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".geojson\")\n  #   },\n  #   content = function(file) {\n  #     df <- plot_df()   # <-- this matches the table + map filters/cap\n  #     txt <- make_caltopo_geojson(df)\n  #     writeLines(txt, con = file, useBytes = TRUE)\n  #   }\n  # )\n  \n  \n  output$dl_filtered_csv <- downloadHandler(\n    filename = function() {\n      paste0(\"movebank_filtered_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".csv\")\n    },\n    content = function(file) {\n      df <- plot_df()  # filtered + capped, with all fields\n      readr::write_csv(df, file)\n    }\n  )\n  \n  \n  \n  # Base map\n  output$map <- renderLeaflet({\n    leaflet() %>%\n      addProviderTiles(\"CartoDB.Positron\", group = \"Light\") %>%\n      addProviderTiles(\"CartoDB.DarkMatter\", group = \"Dark\") %>%\n      addProviderTiles(\"Esri.WorldImagery\", group = \"Satellite\") %>%\n      addProviderTiles(\"Esri.WorldTopoMap\", group = \"Topo\") %>%\n      addTiles(\n        urlTemplate = \"https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}\",\n        attribution = \"USGS The National Map\",\n        group = \"USGS Topo\"\n      ) %>% \n      addScaleBar(position = \"bottomleft\") %>%\n      addLayersControl(\n        baseGroups = c(\"Light\", \"Dark\", \"Satellite\", \"Topo\", \"USGS Topo\"),\n        options = layersControlOptions(collapsed = TRUE)\n      )\n  })\n  \n  # Points + legend + zoom (shinylive-safe palettes)\n  observeEvent(\n    list(plot_df(), input$pt_radius, input$pt_color_mode, input$pt_color_single),\n    {\n      df <- plot_df()\n      proxy <- leafletProxy(\"map\") %>%\n        clearGroup(\"points\") %>%\n        clearGroup(\"selected\") %>%\n        removeControl(\"points_legend\")\n      \n      if (nrow(df) == 0) return()\n      \n      r <- input$pt_radius %||% 3\n      mode <- input$pt_color_mode %||% \"by_id\"\n      \n      if (identical(mode, \"single\")) {\n        col <- input$pt_color_single %||% \"#1f77b4\"\n        cols <- rep(col, nrow(df))\n      } else if (\"individual_local_identifier\" %in% names(df)) {\n        ids <- as.character(df$individual_local_identifier)\n        u <- sort(unique(ids))\n        \n        cols_u <- grDevices::hcl(\n          h = seq(15, 375, length.out = length(u) + 1)[-(length(u) + 1)],\n          c = 100, l = 55\n        )\n        col_map <- setNames(cols_u, u)\n        cols <- unname(col_map[ids])\n        \n        proxy <- proxy %>% addLegend(\n          position = \"bottomright\",\n          colors = cols_u,\n          labels = u,\n          title = \"individual_local_identifier\",\n          opacity = 1,\n          layerId = \"points_legend\"\n        )\n      } else {\n        cols <- rep(\"#1f77b4\", nrow(df))\n      }\n      \n      popup_txt <- paste0(\n        \"<b>individual:<\/b> \", (df$individual_local_identifier %||% \"\"),\n        \"<br><b>time (PT):<\/b> \", (df$timestamp_pacific %||% \"\"),\n        \"<br><b>lat:<\/b> \", df$location_lat,\n        \"<br><b>lon:<\/b> \", df$location_long\n      )\n      \n      proxy %>%\n        addCircleMarkers(\n          data = df,\n          lng = ~location_long,\n          lat = ~location_lat,\n          radius = r,\n          stroke = FALSE,\n          fillOpacity = 0.5,\n          color = cols,\n          popup = popup_txt,\n          group = \"points\",\n          layerId = ~row_id\n        )\n      \n      if (isTRUE(input$fit_data)) {\n        proxy %>% fitBounds(\n          lng1 = min(df$location_long, na.rm = TRUE),\n          lat1 = min(df$location_lat, na.rm = TRUE),\n          lng2 = max(df$location_long, na.rm = TRUE),\n          lat2 = max(df$location_lat, na.rm = TRUE)\n        )\n      }\n    },\n    ignoreInit = TRUE\n  )\n  \n  # Tracks: gradient segments + mini key (shinylive-safe palette)\n  observeEvent(list(track_df(), track_redraw()), {\n    df <- track_df()\n    proxy <- leafletProxy(\"map\") %>%\n      clearGroup(\"tracks\") %>%\n      removeControl(\"track_key\")\n    \n    if (nrow(df) < 2) return()\n    \n    ids <- unique(df$individual_local_identifier)\n    \n    for (id in ids) {\n      d <- df[df$individual_local_identifier == id, , drop = FALSE]\n      if (nrow(d) < 2) next\n      \n      if (\"timestamp_utc\" %in% names(d) && any(!is.na(d$timestamp_utc))) {\n        d <- d[order(d$timestamp_utc), , drop = FALSE]\n      }\n      \n      nseg <- nrow(d) - 1\n      if (nseg < 1) next\n      \n      # simple fixed gradient (no viridis dependency)\n      pal_seg <- grDevices::colorRampPalette(c(\"#440154\", \"#21908C\", \"#FDE725\"))(nseg)\n      \n      if (isTRUE(input$show_track_key)) {\n        new_col <- pal_seg[nseg]\n        old_col <- pal_seg[1]\n        proxy <- proxy %>%\n          addControl(\n            html = track_key_html(new_col, old_col),\n            position = \"bottomright\",\n            layerId = \"track_key\"\n          )\n      }\n      \n      for (i in seq_len(nseg)) {\n        proxy <- proxy %>%\n          addPolylines(\n            lng = c(d$location_long[i], d$location_long[i + 1]),\n            lat = c(d$location_lat[i],  d$location_lat[i + 1]),\n            group = \"tracks\",\n            opacity = 0.9,\n            weight = 4,\n            color = pal_seg[i]\n          )\n      }\n      \n      proxy <- proxy %>%\n        addCircleMarkers(\n          lng = d$location_long[1],\n          lat = d$location_lat[1],\n          group = \"tracks\",\n          radius = 5,\n          stroke = TRUE,\n          weight = 2,\n          opacity = 1,\n          fillOpacity = 1,\n          color = \"white\",\n          fillColor = pal_seg[1],\n          popup = paste0(\"<b>\", id, \"<\/b><br>Older<br>\", d$timestamp_pacific[1] %||% \"\")\n        ) %>%\n        addCircleMarkers(\n          lng = d$location_long[nrow(d)],\n          lat = d$location_lat[nrow(d)],\n          group = \"tracks\",\n          radius = 7,\n          stroke = TRUE,\n          weight = 2,\n          opacity = 1,\n          fillOpacity = 1,\n          color = \"white\",\n          fillColor = pal_seg[nseg],\n          popup = paste0(\"<b>\", id, \"<\/b><br>Newer<br>\", d$timestamp_pacific[nrow(d)] %||% \"\")\n        )\n    }\n  }, ignoreInit = TRUE)\n  \n  # Table\n  output$tbl <- renderDT({\n    df <- plot_df()\n    req(df)\n    \n    desired <- c(\n      \"individual_local_identifier\",\n      \"timestamp_pacific\",\n      \"location_lat\",\n      \"location_long\",\n      \"gps_fix_type_raw\"\n    )\n    \n    cols <- input$show_cols\n    if (is.null(cols) || length(cols) == 0) cols <- desired\n    cols <- intersect(cols, names(df))\n    \n    front <- intersect(desired, cols)\n    rest  <- setdiff(cols, front)\n    cols_ordered <- c(front, rest)\n    \n    df_show <- df[, cols_ordered, drop = FALSE]\n    \n    datatable(\n      df_show,\n      selection = list(mode = \"multiple\"),\n      class = \"compact stripe nowrap\",\n      options = list(\n        paging = FALSE,\n        scrollY = \"320px\",\n        scrollX = TRUE,\n        scrollXInner = \"200%\",\n        scrollCollapse = TRUE,\n        autoWidth = FALSE,\n        deferRender = TRUE\n      )\n    )\n  })\n  \n  \n  make_caltopo_tracks_geojson <- function(df) {\n    if (is.null(df) || nrow(df) < 2) {\n      return('{\"type\":\"FeatureCollection\",\"features\":[]}')\n    }\n    if (!(\"individual_local_identifier\" %in% names(df))) {\n      return('{\"type\":\"FeatureCollection\",\"features\":[]}')\n    }\n\n    # order within id by time if available\n    if (\"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))) {\n      df <- df[order(df$individual_local_identifier, df$timestamp_utc), , drop = FALSE]\n    } else {\n      df <- df[order(df$individual_local_identifier), , drop = FALSE]\n    }\n\n    ids <- unique(as.character(df$individual_local_identifier))\n\n    # define a consistent global gradient based on time across the *track_df*\n    has_time <- \"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))\n    if (has_time) {\n      tmin <- suppressWarnings(min(df$timestamp_utc, na.rm = TRUE))\n      tmax <- suppressWarnings(max(df$timestamp_utc, na.rm = TRUE))\n      span <- as.numeric(difftime(tmax, tmin, units = \"secs\"))\n      if (!is.finite(span) || span <= 0) span <- 1\n    }\n\n    features <- list()\n\n    for (id in ids) {\n      d <- df[df$individual_local_identifier == id, , drop = FALSE]\n      d <- d[is.finite(d$location_lat) & is.finite(d$location_long), , drop = FALSE]\n      if (nrow(d) < 2) next\n\n      coords <- lapply(seq_len(nrow(d)), function(i) {\n        list(as.numeric(d$location_long[i]), as.numeric(d$location_lat[i]))\n      })\n\n      # pick one color per track based on \"recency\" of last point (mirrors gradient idea)\n      # if (has_time && any(!is.na(d$timestamp_utc))) {\n      #   tlast <- suppressWarnings(max(d$timestamp_utc, na.rm = TRUE))\n      #   p <- as.numeric(difftime(tlast, tmin, units = \"secs\")) / span\n      #   p <- max(0, min(1, p))\n      #   col_hex <- grDevices::colorRampPalette(c(\"#440154\", \"#21908C\", \"#FDE725\"))(101)[1 + round(p * 100)]\n      # } else {\n      #   col_hex <- \"#21908C\"\n      # }\n      # cal_color <- toupper(gsub(\"^#\", \"\", col_hex))\n      cal_color <- \"#440154\"\n\n      start_pt <- d$timestamp_pacific[1] %||% \"\"\n      end_pt   <- d$timestamp_pacific[nrow(d)] %||% \"\"\n\n      desc <- paste0(\n        \"id: \", id, \"\\n\",\n        \"start: \", start_pt, \"\\n\",\n        \"end: \", end_pt, \"\\n\",\n        \"n_points: \", nrow(d)\n      )\n\n      features[[length(features) + 1]] <- list(\n        type = \"Feature\",\n        geometry = list(\n          type = \"LineString\",\n          coordinates = coords\n        ),\n        properties = list(\n          title = paste0(\"track: \", id),\n          description = desc,\n          class = \"Line\",\n          stroke = cal_color,      # common Caltopo style fields\n          `stroke-width` = 3,\n          `stroke-opacity` = 0.9\n        )\n      )\n    }\n\n    geo <- list(type = \"FeatureCollection\", features = features)\n    jsonlite::toJSON(geo, auto_unbox = TRUE, null = \"null\", digits = 8)\n  }\n\n  # output$dl_caltopo_tracks_geojson <- downloadHandler(\n  #   filename = function() {\n  #     paste0(\"caltopo_tracks_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".geojson\")\n  #   },\n  #   content = function(file) {\n  #     # track_df() already requires show_tracks==TRUE and selected individuals\n  #     df <- track_df()\n  #     txt <- make_caltopo_tracks_geojson(df)\n  #     writeLines(txt, con = file, useBytes = TRUE)\n  #   }\n  # )\n  \n  \n  observeEvent(input$btn_csv, {\n    df <- plot_df()\n    \n    tmp <- tempfile(fileext = \".csv\")\n    readr::write_csv(df, tmp)\n    txt <- paste(readLines(tmp, warn = FALSE), collapse = \"\\n\")\n    unlink(tmp)\n    \n    session$sendCustomMessage(\"download_text_file\", list(\n      filename = paste0(\"movebank_filtered_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".csv\"),\n      mimetype = \"text/csv;charset=utf-8\",\n      text = txt\n    ))\n  })\n  \n  observeEvent(input$btn_pts_geojson, {\n    df <- plot_df()\n    txt <- make_caltopo_geojson(df)\n    \n    session$sendCustomMessage(\"download_text_file\", list(\n      filename = paste0(\"caltopo_points_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".geojson\"),\n      mimetype = \"application/geo+json;charset=utf-8\",\n      text = txt\n    ))\n  })\n  \n  observeEvent(input$btn_tracks_geojson, {\n    # NOTE: this will only work if track_df() requirements are met\n    df <- track_df()\n    txt <- make_caltopo_tracks_geojson(df)\n    \n    session$sendCustomMessage(\"download_text_file\", list(\n      filename = paste0(\"caltopo_tracks_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".geojson\"),\n      mimetype = \"application/geo+json;charset=utf-8\",\n      text = txt\n    ))\n  })\n  \n  \n  \n  \n  # Highlight selected rows on map\n  observeEvent(input$tbl_rows_selected, {\n    df <- plot_df()\n    req(df)\n    sel <- input$tbl_rows_selected\n    \n    proxy <- leafletProxy(\"map\") %>% clearGroup(\"selected\")\n    if (length(sel) == 0) return()\n    \n    dsel <- df[sel, , drop = FALSE]\n    if (nrow(dsel) == 0) return()\n    \n    proxy %>%\n      addCircleMarkers(\n        data = dsel,\n        lng = ~location_long,\n        lat = ~location_lat,\n        radius = 7,\n        stroke = TRUE,\n        weight = 2,\n        opacity = 1,\n        fillOpacity = 0.95,\n        group = \"selected\"\n      )\n    \n    if (isTRUE(input$fit_selected)) {\n      if (nrow(dsel) == 1) {\n        proxy %>% setView(dsel$location_long[1], dsel$location_lat[1], zoom = 12)\n      } else {\n        proxy %>% fitBounds(\n          lng1 = min(dsel$location_long, na.rm = TRUE),\n          lat1 = min(dsel$location_lat, na.rm = TRUE),\n          lng2 = max(dsel$location_long, na.rm = TRUE),\n          lat2 = max(dsel$location_lat, na.rm = TRUE)\n        )\n      }\n    }\n  })\n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"CopyOfapp_working20260210.bak","content":"# app.R\nlibrary(shiny)\nlibrary(leaflet)\nlibrary(readr)\nlibrary(DT)\n\n`%||%` <- function(a, b) if (!is.null(a)) a else b\nTZ_LOCAL <- \"America/Los_Angeles\"  # Pacific\n\nui <- fluidPage(\n  tags$h2(\"Movebank Data Viewer\"),\n  \n  tags$style(HTML(\"\n    .map-wrap { width: 100%; }\n    .map-tall { height: 760px; }\n    .map-short { height: 520px; }\n\n    table.dataTable tbody th, table.dataTable tbody td { font-size: 12px; }\n    table.dataTable thead th { font-size: 12px; }\n\n    .tbl-wrap { height: 340px; overflow: auto; }\n\n    div.dataTables_wrapper { width: 100%; }\n    div.dataTables_scroll { width: 100%; }\n    div.dataTables_scrollBody {\n      overflow-x: auto !important;\n      overflow-y: auto !important;\n    }\n    div.dataTables_scrollHeadInner,\n    div.dataTables_scrollHeadInner table,\n    div.dataTables_scrollBody table.dataTable {\n      width: max-content !important;\n    }\n    table.dataTable { white-space: nowrap; }\n\n    .color-row { display:flex; align-items:center; gap:10px; }\n    .color-row label { margin:0; font-weight:600; }\n    .color-row input[type='color'] { width:46px; height:30px; padding:0; border:none; background:transparent; }\n  \")),\n  \n  fluidRow(\n    column(\n      4,\n      wellPanel(\n        tabsetPanel(\n          id = \"left_tabs\",\n          \n          tabPanel(\n            \"Data\",\n            textInput(\"mb_user\", \"Movebank username\", value = \"r6snrf\"),\n            passwordInput(\"mb_pass\", \"Movebank password\", value = \"\"),\n            numericInput(\"study_id\", \"Study ID\", value = 8038997102, min = 1, step = 1),\n            textInput(\"sensor_type_id\", \"Sensor type id (optional)\", value = \"\"),\n            checkboxInput(\"accept_license\", \"accept_license=true\", value = FALSE),\n            \n            tags$hr(),\n            \n            sliderInput(\n              \"max_points\",\n              \"Max points to display (after filtering)\",\n              min = 200, max = 20000, value = 5000, step = 200\n            ),\n            tags$small(style=\"display:block; margin-top:-6px; color:#666;\",\n                       \"If filtered data exceeds this, we keep the most recent points.\"),\n            \n            tags$hr(),\n            \n            actionButton(\"fetch\", \"Load Collar Data\"),\n            \n            tags$hr(),\n            \n            tags$strong(\"Newest point (Pacific): \"),\n            textOutput(\"newest_pt_local\", inline = TRUE),\n            \n            tags$hr(),\n            \n          \n            \n            \n            checkboxInput(\"fit_data\", \"Zoom to data after plotting\", value = TRUE),\n            \n            tags$hr(),\n            verbatimTextOutput(\"status\")\n          ),\n          \n          tabPanel(\n            \"Filtering\",\n            selectInput(\n              \"last_n_days\",\n              \"Filter: last N days (anchored to newest loaded data point)\",\n              choices = c(\"Off\" = \"off\", \"1\" = \"1\", \"2\" = \"2\", \"3\" = \"3\", \"5\" = \"5\", \"10\" = \"10\"),\n              selected = \"off\"\n            ),\n            uiOutput(\"date_ui\"),\n            tags$small(style=\"display:block; margin-top:-6px; color:#666;\",\n                       \"If 'last N days' is set, it overrides the date range.\"),\n            checkboxInput(\n              \"keep_qpf_only\",\n              \"Keep only good fixes (gps_fix_type_raw contains 'QFP')\",\n              value = FALSE\n            ),\n            \n          ),\n          \n          tabPanel(\n            \"Table\",\n            checkboxInput(\"show_table\", \"Show table (split view)\", value = TRUE),\n            checkboxInput(\"fit_selected\", \"Zoom to selected rows\", value = FALSE),\n            tags$hr(),\n            uiOutput(\"col_ui\")\n          ),\n          \n          tabPanel(\n            \"Display\",\n            sliderInput(\"pt_radius\", \"Point size\", min = 1, max = 12, value = 3, step = 1),\n            \n            selectInput(\n              \"pt_color_mode\",\n              \"Point color\",\n              choices = c(\"By individual\" = \"by_id\", \"Single color\" = \"single\"),\n              selected = \"by_id\"\n            ),\n            \n            conditionalPanel(\n              condition = \"input.pt_color_mode === 'single'\",\n              tags$div(\n                class = \"color-row\",\n                tags$label(`for` = \"pt_color_single\", \"Pick color:\"),\n                tags$input(id = \"pt_color_single\", type = \"color\", value = \"#1f77b4\")\n              )\n            ),\n            \n            tags$hr(),\n            \n            selectizeInput(\"ind_select\", \"Individuals for tracks (optional)\", choices = NULL, multiple = TRUE),\n            checkboxInput(\"show_tracks\", \"Draw tracks for selected individuals\", value = FALSE),\n            checkboxInput(\"show_track_key\", \"Show track color key\", value = TRUE),\n            \n            helpText(\"More display controls coming soon.\")\n          )\n        )\n      )\n    ),\n    \n    column(\n      8,\n      tags$div(\n        id = \"map_container\",\n        class = \"map-wrap map-short\",\n        leafletOutput(\"map\", height = \"100%\")\n      ),\n      \n      conditionalPanel(\n        condition = \"input.show_table === true\",\n        tags$div(style = \"height: 12px;\"),\n        div(class = \"tbl-wrap\", DTOutput(\"tbl\"))\n      )\n    )\n  ),\n  \n  # ---- JS fetcher + map resize handler + color picker binding ----\n  tags$script(HTML(\"\n  function basicAuthHeader(user, pass) {\n    return 'Basic ' + btoa(user + ':' + pass);\n  }\n\n  async function fetchMovebankCSV(payload) {\n    const { study_id, sensor_type_id, accept_license, user, pass } = payload;\n\n    let url = 'https://www.movebank.org/movebank/service/direct-read'\n            + '?entity_type=event'\n            + '&study_id=' + encodeURIComponent(study_id)\n            + '&attributes=all'\n            + '&format=csv';\n\n    if (sensor_type_id && sensor_type_id.trim() !== '') {\n      url += '&sensor_type_id=' + encodeURIComponent(sensor_type_id.trim());\n    }\n    if (accept_license) {\n      url += '&accept_license=true';\n    }\n\n    try {\n      Shiny.setInputValue('mb_status', 'Fetching…', {priority: 'event'});\n\n      const res = await fetch(url, {\n        method: 'GET',\n        mode: 'cors',\n        headers: { 'Authorization': basicAuthHeader(user, pass) }\n      });\n\n      if (!res.ok) {\n        const txt = await res.text();\n        throw new Error('HTTP ' + res.status + ': ' + txt.slice(0, 300));\n      }\n\n      const csvText = await res.text();\n      Shiny.setInputValue('mb_csv_text', csvText, {priority: 'event'});\n      Shiny.setInputValue('mb_status', 'Success: received ' + csvText.length + ' bytes', {priority: 'event'});\n    } catch (err) {\n      Shiny.setInputValue('mb_status', 'Error: ' + err.message, {priority: 'event'});\n      Shiny.setInputValue('mb_csv_text', null, {priority: 'event'});\n    }\n  }\n\n  Shiny.addCustomMessageHandler('fetch_movebank', function(payload) {\n    fetchMovebankCSV(payload);\n  });\n\n  Shiny.addCustomMessageHandler('set_map_height', function(payload) {\n    var el = document.getElementById('map_container');\n    if (!el) return;\n\n    el.classList.remove('map-tall','map-short');\n    el.classList.add(payload.tall ? 'map-tall' : 'map-short');\n\n    setTimeout(function() {\n      if (window.LeafletWidget && LeafletWidget.maps && LeafletWidget.maps.map) {\n        LeafletWidget.maps.map.invalidateSize(true);\n      }\n    }, 80);\n  });\n\n  // ---- Bind native <input type=\\\"color\\\"> to Shiny ----\n  function bindColorPicker() {\n    var el = document.getElementById('pt_color_single');\n    if (!el) return;\n\n    Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n\n    el.addEventListener('input', function() {\n      Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n    });\n    el.addEventListener('change', function() {\n      Shiny.setInputValue('pt_color_single', el.value, {priority: 'event'});\n    });\n  }\n\n  document.addEventListener('DOMContentLoaded', function() {\n    setTimeout(bindColorPicker, 0);\n  });\n\n  document.addEventListener('shiny:connected', function() {\n    setTimeout(bindColorPicker, 0);\n  });\n\n  if (window.jQuery) {\n    $(document).on('shiny:value', function() {\n      setTimeout(bindColorPicker, 0);\n    });\n  }\n  \"))\n)\n\nserver <- function(input, output, session) {\n  \n  raw_dat <- reactiveVal(NULL)\n  \n  output$newest_pt_local <- renderText({\n    df <- raw_dat()\n    if (is.null(df) || !(\"timestamp_utc\" %in% names(df)) || all(is.na(df$timestamp_utc))) {\n      return(\"—\")\n    }\n    tmax <- suppressWarnings(max(df$timestamp_utc, na.rm = TRUE))\n    if (!is.finite(tmax)) return(\"—\")\n    \n    paste0(format(tmax, tz = TZ_LOCAL, usetz = TRUE), \"  (n=\", nrow(df), \")\")\n  })\n  \n  \n  # ---- Track key ----\n  track_key_html <- function(new_col, old_col) {\n    sprintf(\"\n    <div style='background: rgba(255,255,255,0.92); padding: 6px 8px; border-radius: 6px;\n                box-shadow: 0 1px 4px rgba(0,0,0,0.25); font-size: 12px; line-height: 14px;'>\n      <div style='display:flex; align-items:center; gap:8px;'>\n        <span style='display:inline-block; width:14px; height:14px; background:%s; border:1px solid #333;'><\/span>\n        <span>Newer<\/span>\n      <\/div>\n      <div style='display:flex; align-items:center; gap:8px; margin-top:4px;'>\n        <span style='display:inline-block; width:14px; height:14px; background:%s; border:1px solid #333;'><\/span>\n        <span>Older<\/span>\n      <\/div>\n    <\/div>\", new_col, old_col\n    )\n  }\n  \n  # ---- track redraw trigger (stable) ----\n  track_redraw <- reactiveVal(0)\n  \n  observeEvent(input$show_tracks, {\n    if (isTRUE(input$show_tracks)) {\n      session$onFlushed(function() {\n        track_redraw(isolate(track_redraw()) + 1)\n      }, once = TRUE)\n    } else {\n      leafletProxy(\"map\") %>%\n        clearGroup(\"tracks\") %>%\n        removeControl(\"track_key\")\n    }\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$ind_select, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$date_rng, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$last_n_days, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  observeEvent(input$max_points, {\n    if (isTRUE(input$show_tracks)) track_redraw(isolate(track_redraw()) + 1)\n  }, ignoreInit = TRUE)\n  \n  # ---- Fetch ----\n  observeEvent(input$fetch, {\n    req(input$mb_user, input$mb_pass, input$study_id)\n    session$sendCustomMessage(\"fetch_movebank\", list(\n      user = input$mb_user,\n      pass = input$mb_pass,\n      study_id = input$study_id,\n      sensor_type_id = input$sensor_type_id,\n      accept_license = isTRUE(input$accept_license)\n    ))\n  })\n  \n  observeEvent(input$mb_csv_text, {\n    req(input$mb_csv_text)\n    \n    df <- readr::read_csv(I(input$mb_csv_text), show_col_types = FALSE)\n    names(df) <- gsub(\"-\", \"_\", names(df))\n    \n    req(\"location_lat\" %in% names(df), \"location_long\" %in% names(df))\n    \n    if (\"timestamp\" %in% names(df)) {\n      df$timestamp_utc <- suppressWarnings(as.POSIXct(df$timestamp, tz = \"UTC\"))\n    } else {\n      df$timestamp_utc <- as.POSIXct(NA)\n    }\n    \n    df$timestamp_pacific <- ifelse(\n      is.na(df$timestamp_utc),\n      NA_character_,\n      format(df$timestamp_utc, tz = TZ_LOCAL, usetz = TRUE)\n    )\n    \n    df$row_id <- seq_len(nrow(df))\n    raw_dat(df)\n  })\n  \n  output$status <- renderText(input$mb_status %||% \"Idle.\")\n  \n  observeEvent(input$show_table, {\n    session$sendCustomMessage(\"set_map_height\", list(tall = !isTRUE(input$show_table)))\n  }, ignoreInit = FALSE)\n  \n  # Date UI\n  output$date_ui <- renderUI({\n    df <- raw_dat()\n    if (is.null(df) || all(is.na(df$timestamp_utc))) {\n      return(helpText(\"Date range: (timestamp not available in data)\"))\n    }\n    pac_dates <- as.Date(df$timestamp_utc, tz = TZ_LOCAL)\n    rng <- range(pac_dates, na.rm = TRUE)\n    \n    dateRangeInput(\n      \"date_rng\",\n      paste0(\"Date range (\", TZ_LOCAL, \")\"),\n      start = rng[1],\n      end = rng[2]\n    )\n  })\n  \n  output$col_ui <- renderUI({\n    df <- raw_dat()\n    if (is.null(df)) return(NULL)\n    \n    desired <- c(\n      \"individual_local_identifier\",\n      \"timestamp_pacific\",\n      \"location_lat\",\n      \"location_long\",\n      \"gps_fix_type_raw\"\n    )\n    default_cols <- desired[desired %in% names(df)]\n    \n    checkboxGroupInput(\n      \"show_cols\",\n      \"Table columns\",\n      choices = names(df),\n      selected = default_cols\n    )\n  })\n  \n  observeEvent(raw_dat(), {\n    df <- raw_dat()\n    if (is.null(df)) return()\n    \n    inds <- if (\"individual_local_identifier\" %in% names(df)) {\n      sort(unique(df$individual_local_identifier))\n    } else character(0)\n    \n    updateSelectizeInput(session, \"ind_select\", choices = inds, selected = character(0), server = TRUE)\n  })\n  \n  # ---- Filtering + capping helpers ----\n  apply_filters <- function(df) {\n    if (is.null(df) || nrow(df) == 0) return(df)\n    \n    df <- df[is.finite(df$location_lat) & is.finite(df$location_long), , drop = FALSE]\n    if (nrow(df) == 0) return(df)\n    \n    # optional fix-quality filter\n    if (isTRUE(input$keep_qpf_only)) {\n      if (\"gps_fix_type_raw\" %in% names(df)) {\n        df <- df[grepl(\"QFP\", df$gps_fix_type_raw %||% \"\", fixed = TRUE), , drop = FALSE]\n      } else {\n        # if field missing, return empty rather than silently ignoring\n        df <- df[0, , drop = FALSE]\n      }\n      if (nrow(df) == 0) return(df)\n    }\n    \n    \n    has_time <- \"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))\n    \n    # last N days anchored to newest loaded point wins\n    if (has_time && !is.null(input$last_n_days) && input$last_n_days != \"off\") {\n      nd <- as.integer(input$last_n_days)\n      end_utc <- suppressWarnings(max(df$timestamp_utc, na.rm = TRUE))\n      if (is.finite(end_utc)) {\n        start_utc <- end_utc - (nd * 86400)\n        df <- df[df$timestamp_utc >= start_utc & df$timestamp_utc <= end_utc, , drop = FALSE]\n      }\n      return(df)\n    }\n    \n    # otherwise date range\n    if (has_time && !is.null(input$date_rng) && all(!is.na(input$date_rng))) {\n      start_local <- as.POSIXct(paste0(input$date_rng[1], \" 00:00:00\"), tz = TZ_LOCAL)\n      end_local   <- as.POSIXct(paste0(input$date_rng[2], \" 23:59:59\"), tz = TZ_LOCAL)\n      \n      start_utc <- as.POSIXct(format(start_local, tz = \"UTC\", usetz = TRUE), tz = \"UTC\")\n      end_utc   <- as.POSIXct(format(end_local,   tz = \"UTC\", usetz = TRUE), tz = \"UTC\")\n      \n      df <- df[df$timestamp_utc >= start_utc & df$timestamp_utc <= end_utc, , drop = FALSE]\n    }\n    \n    df\n  }\n  \n  cap_points <- function(df, nmax) {\n    if (is.null(df) || nrow(df) == 0) return(df)\n    if (is.null(nmax) || !is.finite(nmax) || nrow(df) <= nmax) return(df)\n    \n    if (\"timestamp_utc\" %in% names(df) && any(!is.na(df$timestamp_utc))) {\n      o <- order(df$timestamp_utc, decreasing = TRUE)\n      df <- df[o, , drop = FALSE]\n      df <- df[seq_len(nmax), , drop = FALSE]\n      df <- df[order(df$timestamp_utc), , drop = FALSE]\n    } else {\n      df <- df[seq.int(max(1, nrow(df) - nmax + 1), nrow(df)), , drop = FALSE]\n    }\n    df\n  }\n  \n  plot_df <- reactive({\n    df <- raw_dat()\n    req(df)\n    df2 <- apply_filters(df)\n    cap_points(df2, input$max_points)\n  })\n  \n  track_df <- reactive({\n    df <- raw_dat()\n    req(df)\n    req(isTRUE(input$show_tracks))\n    req(length(input$ind_select) > 0)\n    \n    if (!(\"individual_local_identifier\" %in% names(df))) return(df[0, , drop = FALSE])\n    \n    df2 <- df[df$individual_local_identifier %in% input$ind_select, , drop = FALSE]\n    df2 <- apply_filters(df2)\n    df2 <- cap_points(df2, input$max_points)\n    \n    if (\"timestamp_utc\" %in% names(df2)) {\n      df2 <- df2[order(df2$individual_local_identifier, df2$timestamp_utc), , drop = FALSE]\n    } else {\n      df2 <- df2[order(df2$individual_local_identifier), , drop = FALSE]\n    }\n    df2\n  })\n  \n  # Base map\n  output$map <- renderLeaflet({\n    leaflet() %>%\n      addProviderTiles(\"CartoDB.Positron\", group = \"Light\") %>%\n      addProviderTiles(\"CartoDB.DarkMatter\", group = \"Dark\") %>%\n      addProviderTiles(\"Esri.WorldImagery\", group = \"Satellite\") %>%\n      addProviderTiles(\"Esri.WorldTopoMap\", group = \"Topo\") %>%\n      addTiles(\n        urlTemplate = \"https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}\",\n        attribution = \"USGS The National Map\",\n        group = \"USGS Topo\"\n      ) %>% \n      addScaleBar(position = \"bottomleft\") %>%\n      addLayersControl(\n        baseGroups = c(\"Light\", \"Dark\", \"Satellite\", \"Topo\", \"USGS Topo\"),\n        options = layersControlOptions(collapsed = TRUE)\n      )\n  })\n  \n  # Points + legend + zoom (shinylive-safe palettes)\n  observeEvent(\n    list(plot_df(), input$pt_radius, input$pt_color_mode, input$pt_color_single),\n    {\n      df <- plot_df()\n      proxy <- leafletProxy(\"map\") %>%\n        clearGroup(\"points\") %>%\n        clearGroup(\"selected\") %>%\n        removeControl(\"points_legend\")\n      \n      if (nrow(df) == 0) return()\n      \n      r <- input$pt_radius %||% 3\n      mode <- input$pt_color_mode %||% \"by_id\"\n      \n      if (identical(mode, \"single\")) {\n        col <- input$pt_color_single %||% \"#1f77b4\"\n        cols <- rep(col, nrow(df))\n      } else if (\"individual_local_identifier\" %in% names(df)) {\n        ids <- as.character(df$individual_local_identifier)\n        u <- sort(unique(ids))\n        \n        cols_u <- grDevices::hcl(\n          h = seq(15, 375, length.out = length(u) + 1)[-(length(u) + 1)],\n          c = 100, l = 55\n        )\n        col_map <- setNames(cols_u, u)\n        cols <- unname(col_map[ids])\n        \n        proxy <- proxy %>% addLegend(\n          position = \"bottomright\",\n          colors = cols_u,\n          labels = u,\n          title = \"individual_local_identifier\",\n          opacity = 1,\n          layerId = \"points_legend\"\n        )\n      } else {\n        cols <- rep(\"#1f77b4\", nrow(df))\n      }\n      \n      popup_txt <- paste0(\n        \"<b>individual:<\/b> \", (df$individual_local_identifier %||% \"\"),\n        \"<br><b>time (PT):<\/b> \", (df$timestamp_pacific %||% \"\"),\n        \"<br><b>lat:<\/b> \", df$location_lat,\n        \"<br><b>lon:<\/b> \", df$location_long\n      )\n      \n      proxy %>%\n        addCircleMarkers(\n          data = df,\n          lng = ~location_long,\n          lat = ~location_lat,\n          radius = r,\n          stroke = FALSE,\n          fillOpacity = 0.5,\n          color = cols,\n          popup = popup_txt,\n          group = \"points\",\n          layerId = ~row_id\n        )\n      \n      if (isTRUE(input$fit_data)) {\n        proxy %>% fitBounds(\n          lng1 = min(df$location_long, na.rm = TRUE),\n          lat1 = min(df$location_lat, na.rm = TRUE),\n          lng2 = max(df$location_long, na.rm = TRUE),\n          lat2 = max(df$location_lat, na.rm = TRUE)\n        )\n      }\n    },\n    ignoreInit = TRUE\n  )\n  \n  # Tracks: gradient segments + mini key (shinylive-safe palette)\n  observeEvent(list(track_df(), track_redraw()), {\n    df <- track_df()\n    proxy <- leafletProxy(\"map\") %>%\n      clearGroup(\"tracks\") %>%\n      removeControl(\"track_key\")\n    \n    if (nrow(df) < 2) return()\n    \n    ids <- unique(df$individual_local_identifier)\n    \n    for (id in ids) {\n      d <- df[df$individual_local_identifier == id, , drop = FALSE]\n      if (nrow(d) < 2) next\n      \n      if (\"timestamp_utc\" %in% names(d) && any(!is.na(d$timestamp_utc))) {\n        d <- d[order(d$timestamp_utc), , drop = FALSE]\n      }\n      \n      nseg <- nrow(d) - 1\n      if (nseg < 1) next\n      \n      # simple fixed gradient (no viridis dependency)\n      pal_seg <- grDevices::colorRampPalette(c(\"#440154\", \"#21908C\", \"#FDE725\"))(nseg)\n      \n      if (isTRUE(input$show_track_key)) {\n        new_col <- pal_seg[nseg]\n        old_col <- pal_seg[1]\n        proxy <- proxy %>%\n          addControl(\n            html = track_key_html(new_col, old_col),\n            position = \"bottomright\",\n            layerId = \"track_key\"\n          )\n      }\n      \n      for (i in seq_len(nseg)) {\n        proxy <- proxy %>%\n          addPolylines(\n            lng = c(d$location_long[i], d$location_long[i + 1]),\n            lat = c(d$location_lat[i],  d$location_lat[i + 1]),\n            group = \"tracks\",\n            opacity = 0.9,\n            weight = 4,\n            color = pal_seg[i]\n          )\n      }\n      \n      proxy <- proxy %>%\n        addCircleMarkers(\n          lng = d$location_long[1],\n          lat = d$location_lat[1],\n          group = \"tracks\",\n          radius = 5,\n          stroke = TRUE,\n          weight = 2,\n          opacity = 1,\n          fillOpacity = 1,\n          color = \"white\",\n          fillColor = pal_seg[1],\n          popup = paste0(\"<b>\", id, \"<\/b><br>Older<br>\", d$timestamp_pacific[1] %||% \"\")\n        ) %>%\n        addCircleMarkers(\n          lng = d$location_long[nrow(d)],\n          lat = d$location_lat[nrow(d)],\n          group = \"tracks\",\n          radius = 7,\n          stroke = TRUE,\n          weight = 2,\n          opacity = 1,\n          fillOpacity = 1,\n          color = \"white\",\n          fillColor = pal_seg[nseg],\n          popup = paste0(\"<b>\", id, \"<\/b><br>Newer<br>\", d$timestamp_pacific[nrow(d)] %||% \"\")\n        )\n    }\n  }, ignoreInit = TRUE)\n  \n  # Table\n  output$tbl <- renderDT({\n    df <- plot_df()\n    req(df)\n    \n    desired <- c(\n      \"individual_local_identifier\",\n      \"timestamp_pacific\",\n      \"location_lat\",\n      \"location_long\",\n      \"gps_fix_type_raw\"\n    )\n    \n    cols <- input$show_cols\n    if (is.null(cols) || length(cols) == 0) cols <- desired\n    cols <- intersect(cols, names(df))\n    \n    front <- intersect(desired, cols)\n    rest  <- setdiff(cols, front)\n    cols_ordered <- c(front, rest)\n    \n    df_show <- df[, cols_ordered, drop = FALSE]\n    \n    datatable(\n      df_show,\n      selection = list(mode = \"multiple\"),\n      class = \"compact stripe nowrap\",\n      options = list(\n        paging = FALSE,\n        scrollY = \"320px\",\n        scrollX = TRUE,\n        scrollXInner = \"200%\",\n        scrollCollapse = TRUE,\n        autoWidth = FALSE,\n        deferRender = TRUE\n      )\n    )\n  })\n  \n  # Highlight selected rows on map\n  observeEvent(input$tbl_rows_selected, {\n    df <- plot_df()\n    req(df)\n    sel <- input$tbl_rows_selected\n    \n    proxy <- leafletProxy(\"map\") %>% clearGroup(\"selected\")\n    if (length(sel) == 0) return()\n    \n    dsel <- df[sel, , drop = FALSE]\n    if (nrow(dsel) == 0) return()\n    \n    proxy %>%\n      addCircleMarkers(\n        data = dsel,\n        lng = ~location_long,\n        lat = ~location_lat,\n        radius = 7,\n        stroke = TRUE,\n        weight = 2,\n        opacity = 1,\n        fillOpacity = 0.95,\n        group = \"selected\"\n      )\n    \n    if (isTRUE(input$fit_selected)) {\n      if (nrow(dsel) == 1) {\n        proxy %>% setView(dsel$location_long[1], dsel$location_lat[1], zoom = 12)\n      } else {\n        proxy %>% fitBounds(\n          lng1 = min(dsel$location_long, na.rm = TRUE),\n          lat1 = min(dsel$location_lat, na.rm = TRUE),\n          lng2 = max(dsel$location_long, na.rm = TRUE),\n          lat2 = max(dsel$location_lat, na.rm = TRUE)\n        )\n      }\n    }\n  })\n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"mb_viewer.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"}]
